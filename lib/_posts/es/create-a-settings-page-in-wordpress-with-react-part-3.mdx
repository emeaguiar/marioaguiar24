---
title: Crear una p√°gina de opciones en WordPress con React ‚Äì Parte 3
publishedOn: '2024-01-29'
updatedOn: '2024-10-18T04:06:55.852Z'
description: |-
  Parte tres de una serie de tutoriales donde aprenderemos a crear una p√°gina de
    opciones en WordPress utilizando React y el API de WordPress. Ahora lo que resta es guardar los datos dentro de nuestra base de datos y leerla dentro de nuestra p√°gina de opciones para asegurarnos de no sobre-escribir los datos.
published: true
readingTime: 900
---
Durante la [segunda parte](/blog/create-a-settings-page-in-wordpress-with-react-part-2)
de este tutorial para **crear una p√°gina de opciones en WordPress**, mostr√© como crear
una peque√±a aplicaci√≥n en React que sea mostrada dentro de nuestra p√°gina de
opciones, agregamos un par de campos y estilos; y preparamos el bot√≥n de guardado
para que √©sta funcione. Ahora lo que resta es **guardar los datos** dentro de nuestra
base de datos y leerla dentro de nuestra p√°gina de opciones para asegurarnos de
no sobre-escribir los datos.

## Tabla de Contenido

- [Paso 1: Guardando nuestros datos](#paso-1-guardando-nuestros-datos)
- [Paso 2: Mejorando la experiencia](#paso-2-mejorando-la-experiencia)
- [Conclusi√≥n](#conclusi%C3%B3n)

## Paso 1: Guardando nuestros datos

Comenzando desde donde nos quedamos la √∫ltima vez, afortunadamente WordPress ya
viene con sus utilidades para hacernos la vida m√°s f√°cil, y, si recordamos que
en la segunda parte registramos nuestra opci√≥n utilizando `register_setting`, podemos
utilizar el ID que le dimos para cargar las opciones guardadas en nuestra base de
datos de esta forma:

```jsx
/**
 * WordPress dependencies
 */
import {
    Button,
    Card,
    CardBody,
    CardDivider,
    CardFooter,
    TextControl,
    ToggleControl,
} from '@wordpress/components';
import { useEntityProp } from '@wordpress/core-data';
import { __ } from '@wordpress/i18n';
const Settings = () => {
    const [ apiKey, setApiKey ] = useEntityProp(
        'root',
        'site',
        'mah_api_key'
    );
    const [ toggled, setToggled ] = useEntityProp(
        'root',
        'site',
        'mah_function'
    );
    const saveSettings = () => {
        console.log( 'Guardar' );
    };
    return (
        <>
            <h1>{ __( 'Selecciona las opciones deseadas', 'mah-settings' ) }</h1>
            <Card>
                <CardBody>
                    <TextControl
                        help={ __( 'Ingresa tu API key', 'mah-settings' ) }
                        label={ __( 'API Key', 'mah-settings' ) }
                        onChange={ setApiKey }
                        value={ apiKey || '' }
                    />
                </CardBody>

                <CardDivider />

                <CardBody>
                    <ToggleControl
                        label={ __( 'Activar funcionalidad', 'mah-settings' ) }
                        onChange={ setToggled }
                        checked={ toggled || false }
                    />
                </CardBody>

                <CardFooter>
                    <Button
                        disabled={ ! apiKey }
                        onClick={ saveSettings }
                        variant="primary"
                    >
                        { __( 'Guardar', 'mah-settings' ) }
                    </Button>
                </CardFooter>
            </Card>
        </>
    );
}
export default Settings;
```

Con esto ya estamos **leyendo el valor de nuestra opci√≥n guardado anteriormente**, expliquemos un poco como funciona:

- Cargamos el hook `useEntityProp` que nos ayuda a leer propiedades ya sea del sitio, o de posts en particular
- Esto es evidente en la **linea 18** donde reemplazamos `useState` por `useEntityProp`,
  el _hook_ mantiene en observaci√≥n a nuestro valor para mantener un registro mientras se guarda
- Por √∫ltimo agregamos una condici√≥n al valor de nuestro `TextControl` en donde
  b√°sicamente decimos que is este valor est√° vac√≠o (`null`) entonces regrese una cadena vac√≠a en su lugar (`''`).
- Hacemos lo mismo con nuestro _Toggle_, esto es **para mantener el mismo tipo de
  datos** a√∫n cuando no haya nada guardado anteriormente

Ahora necesitamos **guardar nuestros datos** una vez que se presiona el bot√≥n de
guardar, para ello necesitamos reemplazar la funci√≥n de `saveSettings` por una llamada
a las funciones disponibles en los paquetes `@wordpress/core-data`, y `@wordpress/data`

> [!WARNING] 
> **¬øCual es la diferencia?**
>
> Si la pregunta es el ¬øpor qu√© algunas funciones estan en core-data mientras
> que otras est√°n en data? desafortunadamente no tengo la respuesta,
> s√≥lo sabemos que el equipo que las agreg√≥ supuso que esos eran los mejores
> lugares para colocarlas ü§∑‚Äç‚ôÇÔ∏è

```jsx
/**
 * WordPress dependencies
 */
import {
    Button,
    Card,
    CardBody,
    CardDivider,
    CardFooter,
    TextControl,
    ToggleControl,
} from '@wordpress/components';
import { store as coreStore, useEntityProp } from '@wordpress/core-data';
import { useDispatch } from '@wordpress/data';
import { __ } from '@wordpress/i18n';
const Settings = () => {
    const [ apiKey, setApiKey ] = useEntityProp(
        'root',
        'site',
        'mah_api_key'
    );
    const [ toggled, setToggled ] = useState( false );
    const { saveEditedEntityRecord } = useDispatch( coreStore );
    const saveSettings = () => {
        saveEditedEntityRecord(
            'root',
            'site',
            undefined,
            {
                mah_api_key: apiKey,
                mah_function: toggled,
            }
        );
    };
[‚Ä¶]
```

He agregado solo las partes importantes de nuestras modificaciones, para entender un poco m√°s expliquemos por partes:

- Debemos importar `store`, y le damos el alias `coreStore` (esto es una buena pr√°ctica
  cuando se trabaja con varios) que es en donde est√° guardada la funci√≥n que necesitamos[^1]
- Cargamos la opci√≥n `saveEditedEntityRecord` del **store** utilizando el hook `useDispatch`
- Reemplazamos nuestra funci√≥n de guardado para que **guarde el contenido de nuestras opciones**
  con la funci√≥n que acabamos de cargar

Y eso es todo, ahora una vez hagamos cambios a nuestros controles podremos ver como
su valor persiste al recargar la p√°gina, y podemos utilizarlos en el resto de nuestro sitio:

![Guardando datos en WordPress](/posts/create-a-settings-page-in-wordpress-with-react-part-3/field-state.webp)

## Paso 2: Mejorando la experiencia

A pesar de que ya est√© guardando nuestros datos, a√∫n no hemos terminado ¬øCierto?
_¬øPuedes ver que manera sencilla tenemos de mejorar la experiencia?_

### Paso 2.1: Indicador de carga (Spinner)

Lo m√°s l√≥gico que se me ocurre: **no sabemos cuando ni como se han guardado nuestras opciones**.
No hay **ning√∫n indicador** que nos diga que el bot√≥n funcion√≥ hasta que recargamos
la p√°gina y las vemos ser cargadas en los campos, por lo tanto, podemos comenzar con un simple _Spinner_.

Con unas pocas modificaciones y con la ayuda de nuevo del paquete `@wordpress/components` podemos colocarlo facilmente:

`src/components/settings.js`

```jsx
/**
 * WordPress dependencies
 */
import {
    Button,
    Card,
    CardBody,
    CardDivider,
    CardFooter,
    Spinner,
    TextControl,
    ToggleControl,
} from '@wordpress/components';
import { store as coreStore, useEntityProp } from '@wordpress/core-data';
import { useDispatch } from '@wordpress/data';
import { useState } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
const Settings = () => {
    const [ isLoading, setIsLoading ] = useState( false );
    const [ apiKey, setApiKey ] = useEntityProp(
        'root',
        'site',
        'mah_api_key'
    );
    const [ toggled, setToggled ] = useEntityProp(
        'root',
        'site',
        'mah_function'
    );
    const { saveEditedEntityRecord } = useDispatch( coreStore );
    const saveSettings = async () => {
        setIsLoading( true );
        await saveEditedEntityRecord(
            'root',
            'site',
            undefined,
            {
                mah_api_key: apiKey,
                mah_function: toggled,
            }
        );
        setIsLoading( false );
    };
[‚Ä¶]
```

`src/components/settings.js#49-85`

```jsx
return (
    <>
        <h1>{ __( 'Selecciona las opciones deseadas', 'mah-settings' ) }</h1>
        <Card>
            <CardBody>
                <TextControl
                    help={ __( 'Ingresa tu API key', 'mah-settings' ) }
                    label={ __( 'API Key', 'mah-settings' ) }
                    onChange={ setApiKey }
                    value={ apiKey || '' }
                />
            </CardBody>

            <CardDivider />

            <CardBody>
                <ToggleControl
                    label={ __( 'Activar funcionalidad', 'mah-settings' ) }
                    onChange={ setToggled }
                    checked={ toggled || false }
                />
            </CardBody>

            <CardFooter>
                <Button
                    disabled={ ! apiKey }
                    onClick={ saveSettings }
                    variant="primary"
                >
                    { isLoading && <Spinner /> }
                    { ! isLoading && __( 'Guardar', 'mah-settings' ) }
                </Button>
            </CardFooter>
        </Card>
    </>
);
```

Y el resultado ser√≠a:

![Spinner en WordPress](/posts/create-a-settings-page-in-wordpress-with-react-part-3/spinner.webp)

Veamos que hicimos:

1. Importamos `Spinner` de nuestros componentes de WordPress, **esto es lo que nos dar√° el indicador de carga**
2. Regresamos `useState`, lo utilizaremos para crear una bandera de carga, que est√° deshabilitada por defecto
3. Agregamos la condici√≥n `async` a nuestra funci√≥n de guardado, esto indica al navegador que un `await` esta por venir
4. Cambiamos nuestra bandera de carga a habilitada (esto mostrar√° el Spinner), y
   le indicamos al navegador que **debe esperar el resultado** de la funci√≥n con `await`,
   antes de volver a deshabilitar nuestra bandera
5. Finalmente, indicamos las condiciones para que **si la bandera esta habilitada
   muestre nuestro spinner**, de lo contrario, que muestre nuestro texto

> [!NOTE]
> **¬°Extra!**
>
> Adem√°s de nuestro spinner, muchas veces tambi√©n es bueno **deshabilitar** el bot√≥n
> para que no pueda ser utilizado mientras nuestra funci√≥n carga ¬øPuedes descubrir c√≥mo hacer esto?
>
> _Tip: Estar√° incluido en los dem√°s ejemplos y el repositorio al final del art√≠culo._

### Paso 2.2: Mensaje de √©xito (o de error)

Otra cosa sencilla que podemos hacer es brindar un **mensaje de √©xito** (o error) al
terminar el proceso, este ser√° un poco diferente de lo que hace el editor de WordPress
por defecto[^2], pero a√∫n as√≠ tenemos un componente que podemos utilizar.

Hacemos unas modificaciones la la primera parte de nuestro archivo:

```jsx
/**
 * WordPress dependencies
 */
import {
    Button,
    Card,
    CardBody,
    CardDivider,
    CardFooter,
    Notice,
    Spinner,
    TextControl,
    ToggleControl,
} from '@wordpress/components';
import { store as coreStore, useEntityProp } from '@wordpress/core-data';
import { useDispatch } from '@wordpress/data';
import { useState } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
const Settings = () => {
    const [ isLoading, setIsLoading ] = useState( false );
    const [ showNotice, setShowNotice ] = useState( false );
    const [ apiKey, setApiKey ] = useEntityProp(
        'root',
        'site',
        'mah_api_key'
    );
    const [ toggled, setToggled ] = useEntityProp(
        'root',
        'site',
        'mah_function'
    );
    const { saveEditedEntityRecord } = useDispatch( coreStore );
    const saveSettings = async () => {
        setIsLoading( true );
        await saveEditedEntityRecord(
            'root',
            'site',
            undefined,
            {
                mah_api_key: apiKey,
                mah_function: toggled,
            }
        );
        setShowNotice( true );
        setIsLoading( false );
    };
    return (
        <>
            <h1>{ __( 'Selecciona las opciones deseadas', 'mah-settings' ) }</h1>
            <Card>
                { showNotice && (
                    <CardBody>
                        <Notice
                            isDismissible
                            onDismiss={ () => setShowNotice( false ) }
                            status="success"
                        >
                            { __( 'Guardado con √©xito', 'mah-settings' ) }
                        </Notice>
                    </CardBody>
                ) }
[‚Ä¶]
```

B√°sicamente lo que estamos haciendo es:

1. Importamos el componente Notice de `@wordpress/components`
2. Creamos una bandera que nos ayude a saber **cuando mostrar el mensaje** utilizando de nuevo `useState`
3. Cuando termine el proceso de guardado, habilitamos la bandera para mostrar el mensaje
4. Por encima de nuestras opciones, **preparamos el lugar en donde se mostrar√° el mensaje** y especificamos que s√≥lo se muestre cuando la bandera est√© habilitada
5. Dentro del componente `Notice` especificamos cu√°l ser√° el mensaje y agregamos
   una funci√≥n que **deshabilite nuestra bandera** cuando se de click al bot√≥n de cerrar

Y ahora cuando guardemos nuestras opciones, tendremos un bonito **mensaje de √©xito** igual a este:

![Mensaje de √©xito en WordPress](/posts/create-a-settings-page-in-wordpress-with-react-part-3/success.webp)

> [!CAUTION]
> **¬øY si algo falla?**
>
> En √©ste ejemplo, s√≥lo he agregado un mensaje de √©xito, pero, en caso de que
> queramos tambi√©n saber si algo ha fallado (recomendado) podr√≠amos logarlo con las siguientes modificaciones.
>
> - Crear un state que guarde el mensaje que necesitemos, as√≠ como su `status`
> - Reemplazar nuestra funci√≥n async await for una promesa de formato `.then().catch()`
> - Guardar el mensaje de error en nuestra variable dentro de la funci√≥n `catch`
> - Mostrar nuestro mensaje cambiando el `status` dependiendo de si fue √©xito o error

## Conclusi√≥n

Creo que nuestra p√°gina de opciones se encuentra ahora en un bien lugar, no
esperaba que √©ste tutorial se extendiera tanto pero espero que haya sido √∫til
para alguien. Finalmente logramos **crear nuestra p√°gina de opciones**, para recapitular,
√©sto es lo que hemos hecho hasta ahora:

- Creamos nuestro ambiente, y nuestro plugin
- Creamos nuestra p√°gina de opciones, y registramos un _script_ que se ejecute s√≥lo en ella
- Registramos nuestras opciones globales, y agregamos nuestros controles en React
- Guardamos nuestras opciones en React, y agregamos mejoras en UX

Finalmente, si quieres ver el proyecto completo puedes hacerlo en mi [repositoro en Github](https://github.com/emeaguiar/mah-settings-react/tree/parte-3). Una vez m√°s, todos los comentarios son bienvenidos y cualquier sugerencia sobre qu√© escribir despu√©s tambi√©n. ¬°Hasta la pr√≥xima!

## Leer m√°s‚Ä¶

- [@wordpress/data ‚Äì Block Editor Handbook | Developer.WordPress.org](https://developer.wordpress.org/block-editor/reference-guides/packages/packages-data/)
- [@wordpress/core-data ‚Äì Block Editor Handbook | Developer.WordPress.org](https://developer.wordpress.org/block-editor/reference-guides/packages/packages-core-data/)
- [Usar promesas ‚Äì JavaScript | MDN](https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Using_promises)

[^1]:
    Los `stores` son el lugar en d√≥nde la l√≥gica de la applicaci√≥n vive, en
    un formato de Redux; es d√≥nde se guarda el `state` y los `reducers` de la aplicaci√≥n.

[^2]:
    Dentro del editor utilizariamos `createNotice` que mostrar√≠a nuestro mensaje junto a los
    dem√°s de editor, pero aqu√≠ no hay editor as√≠ que hay que improvisar.
