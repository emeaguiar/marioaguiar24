---
title: Implementando Debounce en Vainilla Javascript
publishedOn: '2024-09-26'
updatedOn: '2024-10-17T23:25:59.167Z'
description: >-
  Un simple tutorial explicando el concepto de Debounce y el como implementarlo
  en vainilla Javascript
published: true
readingTime: 420
---

import AlignWide from '@/components/blog/align-wide';
import Code from '@/components/code/code';
import {
    ExampleOne,
    ExampleTwo,
} from '@/examples/implementing-debounce-in-javascript/es';

Probablemente una de las funciones m√°s utilizadas en el mundo de Javascript es (adem√°s de [throttle](/blog/implementing-throttle-in-vanilla-javascript)) **debounce**. Tanto que muchas veces es la √∫nica funci√≥n que llego a importar de [lodash](https://lodash.com/), pero, por muy peque√±a que sea la librer√≠a de `lodash`, **¬øno es demasiado importar una librer√≠a nueva s√≥lo para una funci√≥n?**

Es por eso que muchas veces puede ser m√°s beneficioso **implementar nuestras propias versiones de este tipo de utilidades**, y lo mejor de todo es que debounce es muy simple de utilizar.

> [!NOTE]
> **¬øQu√© es `debounce`?**
> 
> Cuando hablamos de debounce, nos referimos a una t√©cnica utilizada en programaci√≥n (en Javascript principalmente) en la que **evitamos que un evento se ejecute hasta que cierto tiempo ha pasado**. Esto nos ayuda a prevenir que un evento se ejecute antes de que tengamos las herramientas que necesita.

## El Problema

Antes de comenzar, imaginemos que tenemos un **formulario de b√∫squeda** en nuestra aplicaci√≥n, este enviar√° una petici√≥n a nuestra _API_ para regresar resultados relacionados con las palabras clave que el usuario elija. Para ayudar al usuario a ahorrar preciosos milisegundos y un click, **no agregaremos un bot√≥n de b√∫squeda**, el formulario lo har√° autom√°ticamente:

```jsx
<form>
    <label
        htmlFor='search1'
        className='block text-sm font-medium text-gray-700'
    >
        Ingresa una palabra clave
    </label>
    <input
        type='text'
        id='search1'
        name='search1'
        className='mt-1 block w-full rounded-md border border-gray-300 p-2 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm'
    />
</form>
```

Esto resultar√° en:

<AlignWide>
	<ExampleOne />
</AlignWide>

Ahora, digamos que antes de conectar nuestro formulario a nuestra API, queremos asegurarnos de que funcione, as√≠ que queremos imprimir el valor de este campo en la consola (puedes abrir la consola del navegador y probar el campo tu mismo üòâÔ∏è)

Simplemente agregamos un `console.log` a la funci√≥n de cambio:

```jsx
<form>
    <label
        htmlFor='search1'
        className='block text-sm font-medium text-gray-700'
    >
        Ingresa una palabra clave
    </label>
    <input
        type='text'
        id='search1'
        name='search1'
        className='mt-1 block w-full rounded-md border border-gray-300 p-2 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm'
		onChange={(e) => {
			console.log(e.target.value);
		}}
    />
</form>
```

![Console log de cada cambio en el campo de b√∫squeda](/posts/implementing-debounce-in-javascript/no-debounce.gif)

> [!WARNING]
> ¬øPuedes ver el problema? Cada vez que presionamos una tecla **nuestra funci√≥n de cambio es ejecutada**, imag√≠nate que hubieramos conectado nuestro formulario al API, cada uno de esos logs ser√≠a una petici√≥n a la API, y ¬°de s√≥lo un usuario!
> 
> Ahora imag√≠nate que tuvieramos _10,000 usuarios al d√≠a‚Ä¶_

## La Soluci√≥n

Aqu√≠ es donde entra _debounce_, lo que vamos a hacer es **esperar a que el usuario termine de escribir** antes de ejecutar nuestra funci√≥n de cambio, no necesitamos esperar mucho, s√≥lo algunos milisegundos. De esta forma nos aseguramos de que **solo ejecutamos nuestras peticiones cuando las necesitemos**.

La l√≥gica de _debounce_ no es muy complicada, se basa en algunas pautas muy simples, que son:

1. Se ejecuta un evento (como presionar una tecla)
2. Se inicia un _timer_
3. Si el _mismo_ evento vuelve a ser ejecutado:
	* El timer se elimina
	* Un nuevo timer se inicia
4. Si el timer logra llegar a `0`, la funci√≥n finalmente se ejecuta

Ya que tenemos la l√≥gica que necesitamos, podemos pasar a la parte divertida.
## La implementaci√≥n

Ya que este es un tutorial para **mostrar el funcionamiento de debounce**, no recurrir√© a mi m√©todo habitual para utilizarlo (ya que mi m√©todo habitual es simplemente usar [lodash](https://lodash.com/docs/4.17.15#debounce)), en lugar de eso, tomaremos la l√≥gica que escribimos en los p√°rrafos anteriores y la _traduciremos a Javascript_.

Comencemos con el primer paso

> Se ejecuta un evento (como presionar una tecla)

Por fortuna, en nuestro ejemplo estamos utilizando el evento `onChange`, as√≠ que esto ya se encarga de ese paso.

> [!CAUTION]
> Este blog, y sus ejemplos, est√°n escritos en _[React](https://react.dev/)_.
> 
> `onChange` es un evento que es agregado autom√°ticamente a los elementos `input` cuando son creados en React, **esto no est√° disponible en Javascript convencional**, pero en ese caso podemos utilizar el equivalente:
> 
> ```js
> const input = document.querySelector('#search1');
> input.addEventListener('change', (event) => {
>     console.log(event.target.value); // Aqu√≠ va nuestra l√≥gica
> });
> ```

Antes se acercarnos al evento de cambio, es una buena idea **guardar nuestra funci√≥n para que podamos utilizarla en varios lugares**, as√≠ que crearemos la funci√≥n:

```jsx
const debounce = () => {};
```

Bastante simple, ahora veamos. 

> Se inicia un _timer_

Para crear el timer, primero necesitamos guardarlo en una referencia (as√≠ podemos limpiarlo si es necesario):

```jsx
const debounce = (callback, delay) => {
    let timer;

    return (...args) => {
        // Creamos un nuevo timer.
        timer = setTimeout( () => {
            // Ejecutamos la funci√≥n con los argumentos.
            callback( ...args );
        }, delay );
    };
};
```

> [!NOTE]
> ¬ø`return (...args)`?
>
> Si se te hace raro que creemos una funci√≥n que _regresa otra funci√≥n_, la raz√≥n es que necesitamos 
> una funci√≥n que **reciba los argumentos del evento, pero que se ejecute despu√©s de nuestro timer**.
> Cuando vemos: `addEventListener('change', debounced)`, lo que sucede es que `debounced` se ejecuta primero,
> y despu√©s `change` **env√≠a los argumentos a la funci√≥n que `debounced` regresa**.

> Si el _mismo_ evento vuelve a ser ejecutado:
> * El timer se elimina
> * Un nuevo timer se inicia

Hasta ahora ya tenemos nuestro timer, y hemos especificado que al terminar ejecute nuestra funci√≥n, 
(esto se encarga del punto 4), pero nos falta el punto 3, **limpiar el timer si el evento se repite**.
Como ya tenemos una referencia a nuestro timer, podemos limpiarlo con `clearTimeout`:

```jsx
const debounce = ( callback, delay ) => {
    // Guardamos referencia al timer.
    let timer;

    return (...args) => {
        // Limpiamos el timer si existe.
        clearTimeout( timer );

        // Creamos un nuevo timer.
        timer = setTimeout( () => {
            // Ejecutamos la funci√≥n con los argumentos.
            callback( ...args );
        }, delay );
    };
};
```

¬°Nuestra funci√≥n est√° completa! Para utilizarla con nuestro ejemplo, en lugar de iniciar nuestra funci√≥n original, lo que hacemos es **envolverla en nuestra funci√≥n de `debounce`**, de esta forma:

```jsx
const debounced = debounce((e) => {
    console.log(e.target.value);
}, 500);
```

> [!NOTE]
> Traduciendo esto, quedar√≠a de esta forma:
> 
> ```js
> (e) => {
>    console.log(e.target.value);
> }
> ```
> 
> Ser√≠a nuestro `callback`, y `500` ser√≠a el tiempo de espera en milisegundos, nuestro `delay`.

Ahora, en lugar de utilizar nuestra funci√≥n original, **pasamos nuestra funci√≥n `debounced` al evento `onChange`**:

```jsx
<input
    type='text'
    id='search1'
    name='search1'
    className='mt-1 block w-full rounded-md border border-gray-300 p-2 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm'
    onChange={debounced}
/>
```

O sin usar react:

```jsx
input.addEventListener('change', debounced);
```

Ahora, si volvemos a probar nuestra forma de b√∫squeda, tendremos algo similar a esto:

<AlignWide>
    <ExampleTwo />
</AlignWide>

> [!TIP]
> Puedes probar el ejemplo anterior en la consola del navegador, üòâ

![Ejemplo con debounce](/posts/implementing-debounce-in-javascript/debounced.gif)

Despu√©s de esto, podemos ver una gran mejor√≠a en nuestras llamadas, ya no se registra _todas y cada una_ de las letras que ponemos en el campo, si no que se **espera a que el usuario termine de escribir** antes de hacer la llamada, lo que resulta en muchas **menos y m√°s completas llamadas a nuestra API**.

## Conclusi√≥n

Como podemos ver, esta peque√±a funci√≥n puede llegar a ser de gran ayuda, especialmente cuando ponemos atenci√≥n a la **experiencia del usuario**, en muchos casos, nos puede beneficiar el pausar un momento y esperar a que el usuario nos de algo de *feedback* antes de continuar con nuestros c√°lculos.

Si tienes alguna duda o comentario, no dudes en contactarme, ¬°me encantar√≠a saber tu opini√≥n!
